import { spawn } from "child_process";
import https from "https";
import { randomUUID } from "crypto";
import {
  LLMClient,
  CreateChatCompletionOptions,
  LLMResponse,
  AvailableModel,
} from "@browserbasehq/stagehand";

export class CustomLLMClient extends LLMClient {
  readonly type = "custom";

  private apiKey: string | null;
  private actualModelName: string;
  private oauthToken: string | null = null;
  private apiBaseURL: string;
  private maxRetries = 3;
  private tokenExpiryTime: number = 0; // Track expiry
  private debug = false;

  constructor({
    modelName = "gpt-4o" as AvailableModel,
    apiEndpoint,
    apiKey = null,
    actualModelName = "gpt-4-1-2025-04-14-eastus-dz",
    debug = false
  }: {
    modelName?: AvailableModel;
    apiEndpoint: string;
    apiKey?: string | null;
    actualModelName?: string;
    debug?: boolean;
  }) {
    super(modelName);
    this.apiKey = apiKey;
    this.actualModelName = actualModelName;
    this.apiBaseURL = apiEndpoint.replace(/\/$/, "");
    this.debug = debug;
    this.hasVision = false;
  }

  /**
   * Main Chat completion handler
   */
  async createChatCompletion(params: CreateChatCompletionOptions): Promise<LLMResponse> {
    await this.ensureValidOAuthToken();

    return this.withRetry(async () => {
      const payload = this.buildRequestPayload(params);
      const raw = await this.sendRequest(`/chat/completions`, payload);
      return this.formatResponse(raw);
    });
  }

  /**
   * Build structured provider request from Stagehand format
   */
  private buildRequestPayload(params: CreateChatCompletionOptions) {
    return {
      model: this.actualModelName,
      messages: params.messages.map(m => ({
        role: m.role,
        content: typeof m.content === "string" ? m.content : JSON.stringify(m.content)
      })),
      temperature: params.temperature ?? 0.7,
      max_tokens: params.maxTokens ?? 2048,
      stream: params.stream ?? false,
    };
  }

  /**
   * Send HTTPS Request
   */
  private sendRequest(path: string, body: object): Promise<any> {
    return new Promise((resolve, reject) => {
      const url = new URL(`${this.apiBaseURL}${path}`);
      const requestBody = JSON.stringify(body);

      const req = https.request(
        {
          hostname: url.hostname,
          port: url.port || 443,
          path: url.pathname + url.search,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${this.oauthToken}`,
            "Content-Length": Buffer.byteLength(requestBody),
          },
          timeout: 30000, // 30s safety timeout
        },
        res => {
          let data = "";

          res.on("data", chunk => (data += chunk));
          res.on("end", () => {
            if (res.statusCode === 401) return reject(new Error("AUTH_EXPIRED"));
            if (res.statusCode && res.statusCode >= 400)
              return reject(new Error(`HTTP ${res.statusCode}: ${data}`));

            try {
              resolve(JSON.parse(data));
            } catch {
              reject(new Error(`Invalid JSON response: ${data}`));
            }
          });
        }
      );

      req.on("timeout", () => {
        req.destroy();
        reject(new Error("REQUEST_TIMEOUT"));
      });

      req.on("error", reject);
      req.write(requestBody);
      req.end();
    });
  }

  /**
   * Retry wrapper with exponential backoff
   */
  private async withRetry<T>(fn: () => Promise<T>, retryCount = this.maxRetries): Promise<T> {
    try {
      return await fn();
    } catch (err: any) {
      if (this.debug) console.error("Retry Error:", err.message);

      if (err.message === "AUTH_EXPIRED" && retryCount > 0) {
        await this.refreshOAuthToken();
        return this.withRetry(fn, retryCount - 1);
      }

      if (retryCount > 0) {
        const delay = 300 * (this.maxRetries - retryCount + 1);
        await new Promise(res => setTimeout(res, delay));
        return this.withRetry(fn, retryCount - 1);
      }

      throw err;
    }
  }

  /**
   * Ensure token exists and is not expired
   */
  private async ensureValidOAuthToken() {
    if (!this.oauthToken || Date.now() >= this.tokenExpiryTime) {
      await this.refreshOAuthToken();
    }
  }

  /**
   * Refresh OAuth Token by calling Python script
   */
  private async refreshOAuthToken() {
    if (this.debug) console.log("Refreshing OAuth Token...");

    const tokenData = await new Promise<{ access_token: string; expires_in?: number }>((resolve, reject) => {
      const python = spawn("python3", ["fetch_token.py"]);
      let stdout = "";
      let stderr = "";

      python.stdout.on("data", d => (stdout += d.toString()));
      python.stderr.on("data", d => (stderr += d.toString()));

      python.on("close", code => {
        if (code !== 0) return reject(new Error(`fetch_token.py failed: ${stderr}`));
        try {
          resolve(JSON.parse(stdout.trim()));
        } catch {
          reject(new Error(`Invalid OAuth JSON: ${stdout}`));
        }
      });
    });

    this.oauthToken = tokenData.access_token;
    this.tokenExpiryTime = Date.now() + (tokenData.expires_in ?? 3000) * 1000;
  }

  /**
   * Format provider response to Stagehand format
   */
  private formatResponse(api: any): LLMResponse {
    const content = api?.choices?.[0]?.message?.content ?? "";

    return {
      id: randomUUID(),
      object: "chat.completion",
      created: Math.floor(Date.now() / 1000),
      model: this.actualModelName,
      choices: [
        {
          index: 0,
          message: { role: "assistant", content },
          finish_reason: api?.choices?.[0]?.finish_reason ?? "stop",
        },
      ],
      usage: {
        prompt_tokens: api?.usage?.prompt_tokens ?? 0,
        completion_tokens: api?.usage?.completion_tokens ?? 0,
        total_tokens: api?.usage?.total_tokens ?? 0,
      },
    };
  }
}
